#!/bin/bash
if [ -f "~/.config/git_saver.txt" ]; then
	echo "No se encuentra el archivo de configuracion ~/.config/git_saver.txt"
	exit 1
fi

# colores para echo
COLOR='\033[0;32m'
ERROR='\033[0;31m'
DIVISOR='\033[0;34m'
NOCOLOR='\033[0m'

# modo interactivo para elegir que repos hacer commit o no
interactive=false
if [[ "$1" = "--interactive" ]]; then interactive=true; fi

# preguntar al usuario si quiere pushear los cambios o dejarlos en local
echo -e "Do you want to ${ERROR}PUSH${NOCOLOR} the changes ? (y/n)"
read -r pushear

# expandir el nombre del archivo de configuracion
config_file=$(eval "echo ~/.config/git_saver.txt")

# iniciar el agente ssh
eval $(ssh-agent -s)

# listar las keys ssh disponibles
claves=$(ls ~/.ssh | grep id | grep -v "pub")
numero_claves=$(echo "$claves" | wc -w)

# seleccionar una de las keys ssh
if [ $numero_claves -eq 1 ]; then
	eleccion=$claves
elif [ $numero_claves -gt 1 ]; then
	eleccion=$(echo -e "$claves" | fzf)
else
	echo -e "\nNo se encontraron claves ssh en el dispositivo... "
fi

# Verificar si la clave ya est치 registrada
if [ ! -z "$eleccion" ]; then
	if [ ! -z $(ssh-add -l | grep "$eleccion") ] >/dev/null; then
		echo -e "\nLa clave ya est치 registrada con ssh-add"
	else
		# Registrar la clave con ssh-add
		ssh-add $(find ~/.ssh -name "*$eleccion" -type f)
	fi
fi

# funcion para saber si un repo es git o no
is_git_repo() {
	folder=$1
	if ls -a $folder | grep -q .git; then
		return 1
	fi
	return 0
}

# funcion para hacer push de un archivo
push() {
	folder=$1

	# ASegurarse que sea un repo git
	if is_git_repo $folder; then
		echo -e "\n${DIVISOR}-------------------------${NOCOLOR}"
		echo -e "La ruta ${ERROR}$folder${NOCOLOR} no es un repositorio Git."
		return
	fi

	echo -e "\n${DIVISOR}-------------------------${NOCOLOR}"
	echo -e "Guardando ${COLOR}$folder${NOCOLOR}"
	cd $folder

	# si estamos en mod interactivo, preguntar que hacer
	if [ $interactive = true ]; then
		echo -e "Do you want to commit on this repo ? (y/n)"
		read -r accion
		if [ $accion = "n" ]; then
			return
		fi
	fi

	# commit y hacer push
	git add -A
	git commit -m "feat(git_saver): Autogenerated commit ($(date))"
	# pushear si el usuario dijo que si
	if [[ "$pushear" == "y" ]]; then
		git push
	fi
}

# Loop through each line in the config file
ignore_mode=true
ignorados=""
for regex in $(cat $config_file); do
	# cuando se llega a la linea [files] se comienza la expansion de regexes
	# mientras tanto, todos los archivos son anadidos a la lista de ignorados
	if [ $regex = "[files]" ]; then
		ignore_mode=false
		continue
	fi

	# anadir un archivo a la lista de ignorados
	if [ $ignore_mode = true ]; then
		ignorados+=" $regex"
		continue
	fi

	# Expand the regular expression using eval
	expanded_folders=$(eval "echo $regex")

	# Loop through each folder and perform the desired operation
	for folder in $expanded_folders; do
		# buscar e ignorar el repo en la lista de ignorados
		if $(echo $ignorados | grep -q $(basename $folder)); then
			continue
		fi

		# ASegurarse de que la carpeta exista antes de hacer nada
		if [ ! -d "$folder" ]; then
			# Si la ruta no es v치lida, mostrar un mensaje de error
			echo "La ruta ${COLOR}$folder${NOCOLOR} no es v치lida."
			continue
		fi

		push $folder
	done
done

# preguntar si tambien anadir los cambios de yadm
echo -e "\n${DIVISOR}-------------------------${NOCOLOR}"
echo -e "Do you want to add ${COLOR}yadm${NOCOLOR} changes to ? (y/n)"
read -r pushear
if [[ "$pushear" == "y" ]]; then
	echo -e "Commiting ${COLOR}yadm files${NOCOLOR}"
	yadm add -u
	yadm commit -m "feat(git_saver): Autogenerated commit ($(date))"
	yadm push
fi

# imprimir los repositorios que fueron ignorados
echo -e "\n${DIVISOR}-------------------------${NOCOLOR}"
echo -e "${ERROR}Ignorados${NOCOLOR}"
for repo in $ignorados; do
	echo $repo
done
